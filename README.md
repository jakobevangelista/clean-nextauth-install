# Migration Guide: Moving from Next-Auth to Clerk

## Introduction

Migrating from Next-Auth to Clerk can be daunting, but this guide aims to help you achieve a seamless transition with zero downtime. This guide covers running both middlewares simultaneously, importing users while keeping your application active, and ensuring a smooth experience for your users.

## Prerequisites

Before you begin, ensure you have the following:

- An active Clerk account.
- Your current application using Next-Auth.
- Access to your user database.

## Migration Overview

To ensure a smooth migration with minimal disruption to your users, we will follow these steps:

1. **Add Clerk Middleware and Nest Next-Auth Middleware**
2. **Implement User Creation and Sign-In with Clerk**
3. **Batch Import Existing Users**
4. **Switch Data Access Patterns to Clerk**
5. **Turn Off Next-Auth**

## Migration Steps

### 1. Add Clerk Middleware (/src/app/middelware.ts)

We need Clerk's middleware in order to use useSign in.

First, add the Clerk middleware alongside the existing NextAuth middleware. Clerk middleware has to be the top wrapper for the entire middleware. In the example provided, we put a sample middleware functions within the next auth middleware, you can switch this with whatever middleware custom middleware functions you have.


```js
import { clerkMiddleware } from "@clerk/nextjs/server";

import authConfig from "@/auth.config";
import NextAuth from "next-auth";
import { NextResponse } from "next/server";
import {
  DEFAULT_LOGIN_REDIRECT,
  apiAuthPrefix,
  authRoutes,
  publicRoutes,
} from "./routes";

const { auth } = NextAuth(authConfig);
const nextAuthMiddle = auth(function middleware(req) {
  console.log("MIDDLE WARE WORK NEXT AUTH");

  const { nextUrl } = req;
  const isLoggedIn = !!req.auth;

  const isApiAuthRoute = nextUrl.pathname.startsWith(apiAuthPrefix);
  const isPublicRoute = publicRoutes.includes(nextUrl.pathname);
  const isAuthRoute = authRoutes.includes(nextUrl.pathname);

  if (isApiAuthRoute) {
    return NextResponse.next();
  }

  if (isAuthRoute) {
    if (isLoggedIn) {
      return NextResponse.redirect(new URL(DEFAULT_LOGIN_REDIRECT, nextUrl));
    }
    return NextResponse.next();
  }

  if (!isLoggedIn && !isPublicRoute) {
    return NextResponse.redirect(new URL("/login", nextUrl));
  }

  return NextResponse.next();
});

export default clerkMiddleware(async (clerkauth, req) => {
  console.log("MIDDLE WARE WORK CLERK");
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  await nextAuthMiddle(req); // works but needs AppRouteHandlerFnContext
  return NextResponse.next();
});

export const config = {
  matcher: ["/((?!.*\\..*|_next).*)", "/", "/(api|trpc)(.*)"],
};
```

### 2. Wrap Application in <ClerkProvider> (/src/app/layout.tsx)

Wrap your application layout in the <ClerkProvider> component to enable Clerk authentication.

```js
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import { ClerkProvider } from "@clerk/nextjs";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <ClerkProvider>
      <html lang="en">
        <body className={inter.className}>{children}</body>
      </html>
    </ClerkProvider>
  );
}

```

### 3. Migrate Data Access Patterns

<!-- need to implement code example with diffs graphic -->

Update all data access patterns to use Clerk's auth() instead of NextAuth's auth().

```diff
- import { auth } from "@/auth";
+ import { auth } from "@clerk/nextjs/server"

-  const session = await auth();
-  if (!session) return <div>Not Signed In</div>;

+ const { userId } : { userId: string | null } = auth();
+ if (!userId) <div>Not Signed In</div>;

```


### 4. Trickle Migration

Use the following code to create users in Clerk and sign them in:

#### Server-Side (/src/app/settings/migration/page.tsx)

    Create a server-side function that checks if the current NextAuth user exists in Clerk. If not, create the user in Clerk, generate a sign-in token, and pass it to the frontend. This implementation uses Nextjs App router's server component, but you can do this traditionally by making this an api endpoint that you call from the frontend.

    We are using the "external_id" attribute within the creatuser function. This allows users to have a tenet table to store all user attributes outside of clerk in their own user table.

    We query the tenet table and pass the data to the children as an example of how to use the external_id function.


```js
import { auth } from "@/auth";
import { db } from "@/server/neonDb";
import { userAttributes, users } from "@/server/neonDb/schema";
import { clerkClient } from "@clerk/nextjs/server";
import { eq } from "drizzle-orm";
import ClientClerkComponent from "./_components/clientClerkComponent";

export default async function Migration() {
  const session = await auth();
  if (!session?.user) return <div>Not signed into next-auth</div>;

  console.log("EMAIL: ", session.user.email);

  const searchUser = await clerkClient.users.getUserList({
    emailAddress: [session.user.email],
  });

  let createdUser = null;

  if (searchUser.data.length > 0) {
    createdUser = searchUser.data[0];
    console.log("USER ALREADY EXISTS: ", createdUser);
  } else {
    if (!session.user.email) return <div>Failed to create user in clerk</div>;
    const user = await db.query.users.findFirst({
      where: eq(users.email, session.user.email),
    });

    if (!user) return <div>Failed to find user create user in db</div>;
    createdUser = await clerkClient.users.createUser({
      emailAddress: [session.user.email],
      password: user.password ?? undefined,
      skipPasswordChecks: true,
      externalId: `${user.id}`,
    });
    console.log("USER CREATED: ", createdUser);
  }

  if (!createdUser) return <div>Failed to create user</div>;

  const signInToken = await fetch("https://api.clerk.com/v1/sign_in_tokens", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${process.env.CLERK_SECRET_KEY}`,
    },
    body: JSON.stringify({ user_id: createdUser.id }),
  }).then(res => res.json());

  const userAttribute = await db.query.userAttributes.findFirst({
    where: eq(userAttributes.userId, createdUser.externalId!),
  });

  if (!signInToken.token) return <div>Failed to create sign in token</div>;

  return (
    <>
      <ClientClerkComponent sessionId={signInToken.token} userAttribute={userAttribute?.attribute} />
    </>
  );
}
```

#### Client Side Component (/src/app/(protected)/settings/migration/_components/clientClerkComponent.tsx)

On the frontend, use the token to sign the user into Clerk seamlessly.

We also display the information retrieved from the tenet table.


```js
"use client";

import { UserButton, useSignIn, useUser } from "@clerk/nextjs";
import { useEffect, useState } from "react";

interface ClientClerkComponentProps {
  sessionId: string;
  userAttribute: string | undefined | null;
}

export default function ClientClerkComponent({
  sessionId,
  userAttribute,
}: ClientClerkComponentProps) {
  const { signIn, setActive } = useSignIn();
  const { user } = useUser();
  const [signInProcessed, setSignInProcessed] = useState<boolean>(false);

  useEffect(() => {
    // magic link method to sign in using token
    // instead of passing to url, passed from server
    if (!signIn || !setActive || !sessionId) {
      return;
    }

    const createSignIn = async () => {
      try {
        const res = await signIn.create({
          strategy: "ticket",
          ticket: sessionId,
        });

        console.log("RES: ", res);
        await setActive({
          session: res.createdSessionId,
          beforeEmit: () => setSignInProcessed(true),
        });
      } catch (err) {
        setSignInProcessed(true);
      }
    };

    void createSignIn();
  }, [signIn, setActive, sessionId]);

  if (!sessionId) {
    return <div>no token provided</div>;
  }

  if (!signInProcessed) {
    return <div>loading</div>;
  }

  if (!user) {
    return <div>error invalid token {sessionId}</div>;
  }

  return (
    <>
      <div>Signed in as {user.id}</div>
      <div>User role: {userAttribute}</div>
      <UserButton afterSignOutUrl="/login" />
    </>
  );
}

```

### 5. Batch Import

The batch import handles the migration of inactive users through a scheduled process, ensuring all users are migrated without overwhelming the system.

#### Script to get all users in existing database within a queue (/src/batch/page.tsx)

Store all users in a queue for batch processing. This can be done using a standalone nodejs script. The implementation uses nextjs app router's server components. 

The process is just iterating through all the users, storing them in a queue for the cron job to process individually. Definitely scaling concerns but you can modify this solution to fit your scale.

```js
import { db } from "@/server/db";
import { Redis } from "@upstash/redis";

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL,
  token: process.env.UPSTASH_REDIS_REST_TOKEN,
});

export default function Batch() {
  async function buttonPress() {
    "use server";
    const users = await db.query.users.findMany();

    for (const user of users) {
      await redis.rpush("email", user.email);
      await redis.rpush("password", user.password ?? "null");
      await redis.rpush("id", user.id);
      console.log("IMPORTED: ", user.email);
    }
  }
  return (
    <>
      <form action={buttonPress}>
        <button>Press me</button>
      </form>
    </>
  );
}
```

#### Backend API for Batch Import to import users into Clerk (/src/app/api/batch)

Use a cron job to process the queue and create users in Clerk, respecting rate limits. Using Upstash for the cron job running but you can use any job runner of your choice. Again, does not have to be in nextjs, can be any express-like backend. 

```js
import { clerkClient } from "@clerk/nextjs/server";
import { Receiver } from "@upstash/qstash";
import { Redis } from "@upstash/redis";
import { headers } from "next/headers";

const receiver = new Receiver({
  currentSigningKey: process.env.QSTASH_CURRENT_SIGNING_KEY!,
  nextSigningKey: process.env.QSTASH_NEXT_SIGNING_KEY!,
});

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL,
  token: process.env.UPSTASH_REDIS_REST_TOKEN,
});

export async function POST() {
  const headersList = headers();
  const signature = headersList.get("Upstash-Signature");

  if (!signature) {
    return new Response("No signature", { status: 401 });
  }

  const isValid = await receiver.verify({
    body: "",
    signature,
    url: process.env.WEBHOOK_URL!,
  });

  if (!isValid) {
    return new Response("Invalid signature", { status: 401 });
  }

  const lengthOfQueue = await redis.llen("key");
  const lengthOfLoop = lengthOfQueue > 20 ? 20 : lengthOfQueue;
  for (let i = 0; i < lengthOfLoop; i++) {
    const email = await redis.lpop<string | null>("email");
    const password = await redis.lpop<string | null>("password");
    const id = await redis.lpop<string>("id");
    if (!email) break;

    const searchUser = await clerkClient.users.getUserList({ emailAddress: [email] });

    if (searchUser.data.length > 0) {
      continue;
    } else {
      await clerkClient.users.createUser({
        emailAddress: [email],
        password: password === "null" ? undefined : password!,
        externalId: id!,
        skipPasswordRequirement: true,
        skipPasswordChecks: true,
      });
    }
  }
  console.log("BATCH IMPORTING WORKS");
  return new Response("OK", { status: 200 });
}
```

## How migrations flow works


<!-- I am unsure how much we should hand hold the migrator -->

1. First do the batch import and trickle migration
    - While this is going on, users still sign in and sign up through next-auth, clerk is in the background
2. We migrate all the data access patterns to the new way (using clerk's auth() instead of next auth's auth()), important to test that this works
3. Once all the batch import and trickle migration are finished (all the users are in clerk), we then take out all the data access patterns using next-auth, activate the new data access patterns, and use clerk's sign in flows instead of next auth
    - This step is done in one commit, so make sure you test all your data access changes
    - You don't have to delete the old data access patterns, you can just disable it incase the 

## Wrapping Up
With your users now imported into Clerk and your application updated, you can fully switch to using Clerk for authentication. This guide provides a comprehensive approach to migrating from Next-Auth to Clerk with minimal disruption to